# Generated from /opt/rosbots-rtidl/python/ROSMsg_Parser.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3/")
        buf.write("\u00c3\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\3\2\3\2\3\2\5\2:\n\2\3\3\3\3")
        buf.write("\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3")
        buf.write("\6\3\6\7\6M\n\6\f\6\16\6P\13\6\3\6\3\6\3\7\3\7\3\7\3\7")
        buf.write("\3\b\3\b\3\b\7\b[\n\b\f\b\16\b^\13\b\3\t\3\t\5\tb\n\t")
        buf.write("\3\t\3\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\5\np")
        buf.write("\n\n\3\n\3\n\3\n\3\n\3\n\5\nw\n\n\3\n\3\n\3\n\3\n\3\n")
        buf.write("\5\n~\n\n\3\13\3\13\3\13\5\13\u0083\n\13\3\f\3\f\3\r\3")
        buf.write("\r\3\r\3\r\3\r\3\r\5\r\u008d\n\r\3\16\3\16\3\16\3\16\5")
        buf.write("\16\u0093\n\16\3\17\3\17\5\17\u0097\n\17\3\20\3\20\3\20")
        buf.write("\3\20\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21")
        buf.write("\5\21\u00a7\n\21\3\22\3\22\3\23\3\23\3\24\3\24\3\25\3")
        buf.write("\25\3\26\3\26\3\27\3\27\3\30\5\30\u00b6\n\30\3\30\3\30")
        buf.write("\3\31\5\31\u00bb\n\31\3\31\3\31\3\32\3\32\3\33\3\33\3")
        buf.write("\33\2\2\34\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$")
        buf.write("&(*,.\60\62\64\2\13\4\2\31\31))\5\2\3\22\35\37$$\4\2\24")
        buf.write("\24%%\4\2\25\25&&\3\2\4\r\3\2\16\17\3\2\21\22\3\2\27\30")
        buf.write("\3\2\35\36\2\u00bf\29\3\2\2\2\4;\3\2\2\2\6>\3\2\2\2\b")
        buf.write("E\3\2\2\2\nJ\3\2\2\2\fS\3\2\2\2\16\\\3\2\2\2\20a\3\2\2")
        buf.write("\2\22}\3\2\2\2\24\u0082\3\2\2\2\26\u0084\3\2\2\2\30\u008c")
        buf.write("\3\2\2\2\32\u0092\3\2\2\2\34\u0096\3\2\2\2\36\u0098\3")
        buf.write("\2\2\2 \u00a6\3\2\2\2\"\u00a8\3\2\2\2$\u00aa\3\2\2\2&")
        buf.write("\u00ac\3\2\2\2(\u00ae\3\2\2\2*\u00b0\3\2\2\2,\u00b2\3")
        buf.write("\2\2\2.\u00b5\3\2\2\2\60\u00ba\3\2\2\2\62\u00be\3\2\2")
        buf.write("\2\64\u00c0\3\2\2\2\66:\5\4\3\2\67:\5\6\4\28:\5\b\5\2")
        buf.write("9\66\3\2\2\29\67\3\2\2\298\3\2\2\2:\3\3\2\2\2;<\5\16\b")
        buf.write("\2<=\7\2\2\3=\5\3\2\2\2>?\5\16\b\2?@\7\32\2\2@A\5\16\b")
        buf.write("\2AB\7\32\2\2BC\5\16\b\2CD\7\2\2\3D\7\3\2\2\2EF\5\16\b")
        buf.write("\2FG\7\32\2\2GH\5\16\b\2HI\7\2\2\3I\t\3\2\2\2JN\5\16\b")
        buf.write("\2KM\5\f\7\2LK\3\2\2\2MP\3\2\2\2NL\3\2\2\2NO\3\2\2\2O")
        buf.write("Q\3\2\2\2PN\3\2\2\2QR\7\2\2\3R\13\3\2\2\2ST\7 \2\2TU\5")
        buf.write("\32\16\2UV\5\16\b\2V\r\3\2\2\2W[\5\20\t\2X[\5\22\n\2Y")
        buf.write("[\5\24\13\2ZW\3\2\2\2ZX\3\2\2\2ZY\3\2\2\2[^\3\2\2\2\\")
        buf.write("Z\3\2\2\2\\]\3\2\2\2]\17\3\2\2\2^\\\3\2\2\2_b\5\30\r\2")
        buf.write("`b\5\34\17\2a_\3\2\2\2a`\3\2\2\2bc\3\2\2\2cd\5\26\f\2")
        buf.write("d\21\3\2\2\2ef\5\"\22\2fg\5\26\f\2gh\7\26\2\2hi\5.\30")
        buf.write("\2i~\3\2\2\2jk\5$\23\2kl\5\26\f\2lo\7\26\2\2mp\5.\30\2")
        buf.write("np\5\60\31\2om\3\2\2\2on\3\2\2\2p~\3\2\2\2qr\5*\26\2r")
        buf.write("s\5\26\f\2sv\7\26\2\2tw\5\62\32\2uw\5.\30\2vt\3\2\2\2")
        buf.write("vu\3\2\2\2w~\3\2\2\2xy\5(\25\2yz\5\26\f\2z{\7(\2\2{|\5")
        buf.write("\64\33\2|~\3\2\2\2}e\3\2\2\2}j\3\2\2\2}q\3\2\2\2}x\3\2")
        buf.write("\2\2~\23\3\2\2\2\177\u0080\t\2\2\2\u0080\u0083\7.\2\2")
        buf.write("\u0081\u0083\t\2\2\2\u0082\177\3\2\2\2\u0082\u0081\3\2")
        buf.write("\2\2\u0083\25\3\2\2\2\u0084\u0085\t\3\2\2\u0085\27\3\2")
        buf.write("\2\2\u0086\u008d\5\"\22\2\u0087\u008d\5$\23\2\u0088\u008d")
        buf.write("\5&\24\2\u0089\u008d\5*\26\2\u008a\u008d\5(\25\2\u008b")
        buf.write("\u008d\5\32\16\2\u008c\u0086\3\2\2\2\u008c\u0087\3\2\2")
        buf.write("\2\u008c\u0088\3\2\2\2\u008c\u0089\3\2\2\2\u008c\u008a")
        buf.write("\3\2\2\2\u008c\u008b\3\2\2\2\u008d\31\3\2\2\2\u008e\u0093")
        buf.write("\7\37\2\2\u008f\u0090\7\37\2\2\u0090\u0091\7\23\2\2\u0091")
        buf.write("\u0093\7\37\2\2\u0092\u008e\3\2\2\2\u0092\u008f\3\2\2")
        buf.write("\2\u0093\33\3\2\2\2\u0094\u0097\5\36\20\2\u0095\u0097")
        buf.write("\5 \21\2\u0096\u0094\3\2\2\2\u0096\u0095\3\2\2\2\u0097")
        buf.write("\35\3\2\2\2\u0098\u0099\5\30\r\2\u0099\u009a\t\4\2\2\u009a")
        buf.write("\u009b\t\5\2\2\u009b\37\3\2\2\2\u009c\u009d\5\30\r\2\u009d")
        buf.write("\u009e\7\24\2\2\u009e\u009f\7\33\2\2\u009f\u00a0\7\25")
        buf.write("\2\2\u00a0\u00a7\3\2\2\2\u00a1\u00a2\5\30\r\2\u00a2\u00a3")
        buf.write("\7%\2\2\u00a3\u00a4\7\'\2\2\u00a4\u00a5\7&\2\2\u00a5\u00a7")
        buf.write("\3\2\2\2\u00a6\u009c\3\2\2\2\u00a6\u00a1\3\2\2\2\u00a7")
        buf.write("!\3\2\2\2\u00a8\u00a9\t\6\2\2\u00a9#\3\2\2\2\u00aa\u00ab")
        buf.write("\t\7\2\2\u00ab%\3\2\2\2\u00ac\u00ad\t\b\2\2\u00ad\'\3")
        buf.write("\2\2\2\u00ae\u00af\7\20\2\2\u00af)\3\2\2\2\u00b0\u00b1")
        buf.write("\7\3\2\2\u00b1+\3\2\2\2\u00b2\u00b3\t\t\2\2\u00b3-\3\2")
        buf.write("\2\2\u00b4\u00b6\5,\27\2\u00b5\u00b4\3\2\2\2\u00b5\u00b6")
        buf.write("\3\2\2\2\u00b6\u00b7\3\2\2\2\u00b7\u00b8\7\33\2\2\u00b8")
        buf.write("/\3\2\2\2\u00b9\u00bb\5,\27\2\u00ba\u00b9\3\2\2\2\u00ba")
        buf.write("\u00bb\3\2\2\2\u00bb\u00bc\3\2\2\2\u00bc\u00bd\7\34\2")
        buf.write("\2\u00bd\61\3\2\2\2\u00be\u00bf\t\n\2\2\u00bf\63\3\2\2")
        buf.write("\2\u00c0\u00c1\7,\2\2\u00c1\65\3\2\2\2\219NZ\\aov}\u0082")
        buf.write("\u008c\u0092\u0096\u00a6\u00b5\u00ba")
        return buf.getvalue()


class ROSMsg_Parser ( Parser ):

    grammarFileName = "ROSMsg_Parser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'bool'", "'int8'", "'uint8'", "'byte'", 
                     "'char'", "'int16'", "'uint16'", "'int32'", "'uint32'", 
                     "'int64'", "'uint64'", "'float32'", "'float64'", "'string'", 
                     "'time'", "'duration'", "'/'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'+'", "'-'", "<INVALID>", "'---'", "<INVALID>", 
                     "<INVALID>", "'True'", "'False'" ]

    symbolicNames = [ "<INVALID>", "BOOL", "INT8", "UINT8", "BYTE", "CHAR", 
                      "INT16", "UINT16", "INT32", "UINT32", "INT64", "UINT64", 
                      "FLOAT32", "FLOAT64", "STRING", "TIME", "DURATION", 
                      "SLASH", "OPEN_BRACKET", "CLOSE_BRACKET", "ASSIGNMENT", 
                      "PLUS", "MINUS", "HASH", "MESSAGE_SEPARATOR", "INTEGER_LITERAL", 
                      "REAL_LITERAL", "TRUE", "FALSE", "IDENTIFIER", "ROSBAG_MESSAGE_SEPARATOR", 
                      "WHITESPACES", "NEWLINES", "NEWLINE", "STRING_IDENTIFIER", 
                      "STRING_OPEN_BRACKET", "STRING_CLOSE_BRACKET", "STRING_INTEGER_LITERAL", 
                      "STRING_ASSIGNMENT", "STRING_HASH", "STRING_WHITESPACES", 
                      "STRING_NEWLINE", "STRING_VALUE", "STRIN_ASSIGNMENT_NEWLINE", 
                      "COMMENT", "COMMENT_NEWLINE" ]

    RULE_ros_file_input = 0
    RULE_ros_message_input = 1
    RULE_ros_action_input = 2
    RULE_ros_service_input = 3
    RULE_rosbag_input = 4
    RULE_rosbag_nested_message = 5
    RULE_ros_message = 6
    RULE_field_declaration = 7
    RULE_constant_declaration = 8
    RULE_comment = 9
    RULE_identifier = 10
    RULE_type_def = 11
    RULE_ros_type = 12
    RULE_array_type = 13
    RULE_variable_array_type = 14
    RULE_fixed_array_type = 15
    RULE_integral_type = 16
    RULE_floating_point_type = 17
    RULE_temportal_type = 18
    RULE_string_type = 19
    RULE_boolean_type = 20
    RULE_sign = 21
    RULE_integral_value = 22
    RULE_floating_point_value = 23
    RULE_bool_value = 24
    RULE_string_value = 25

    ruleNames =  [ "ros_file_input", "ros_message_input", "ros_action_input", 
                   "ros_service_input", "rosbag_input", "rosbag_nested_message", 
                   "ros_message", "field_declaration", "constant_declaration", 
                   "comment", "identifier", "type_def", "ros_type", "array_type", 
                   "variable_array_type", "fixed_array_type", "integral_type", 
                   "floating_point_type", "temportal_type", "string_type", 
                   "boolean_type", "sign", "integral_value", "floating_point_value", 
                   "bool_value", "string_value" ]

    EOF = Token.EOF
    BOOL=1
    INT8=2
    UINT8=3
    BYTE=4
    CHAR=5
    INT16=6
    UINT16=7
    INT32=8
    UINT32=9
    INT64=10
    UINT64=11
    FLOAT32=12
    FLOAT64=13
    STRING=14
    TIME=15
    DURATION=16
    SLASH=17
    OPEN_BRACKET=18
    CLOSE_BRACKET=19
    ASSIGNMENT=20
    PLUS=21
    MINUS=22
    HASH=23
    MESSAGE_SEPARATOR=24
    INTEGER_LITERAL=25
    REAL_LITERAL=26
    TRUE=27
    FALSE=28
    IDENTIFIER=29
    ROSBAG_MESSAGE_SEPARATOR=30
    WHITESPACES=31
    NEWLINES=32
    NEWLINE=33
    STRING_IDENTIFIER=34
    STRING_OPEN_BRACKET=35
    STRING_CLOSE_BRACKET=36
    STRING_INTEGER_LITERAL=37
    STRING_ASSIGNMENT=38
    STRING_HASH=39
    STRING_WHITESPACES=40
    STRING_NEWLINE=41
    STRING_VALUE=42
    STRIN_ASSIGNMENT_NEWLINE=43
    COMMENT=44
    COMMENT_NEWLINE=45

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Ros_file_inputContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ros_message_input(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Ros_message_inputContext,0)


        def ros_action_input(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Ros_action_inputContext,0)


        def ros_service_input(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Ros_service_inputContext,0)


        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_ros_file_input

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRos_file_input" ):
                listener.enterRos_file_input(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRos_file_input" ):
                listener.exitRos_file_input(self)




    def ros_file_input(self):

        localctx = ROSMsg_Parser.Ros_file_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_ros_file_input)
        try:
            self.state = 55
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 52
                self.ros_message_input()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 53
                self.ros_action_input()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 54
                self.ros_service_input()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ros_message_inputContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ros_message(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Ros_messageContext,0)


        def EOF(self):
            return self.getToken(ROSMsg_Parser.EOF, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_ros_message_input

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRos_message_input" ):
                listener.enterRos_message_input(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRos_message_input" ):
                listener.exitRos_message_input(self)




    def ros_message_input(self):

        localctx = ROSMsg_Parser.Ros_message_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_ros_message_input)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 57
            self.ros_message()
            self.state = 58
            self.match(ROSMsg_Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ros_action_inputContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ros_message(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ROSMsg_Parser.Ros_messageContext)
            else:
                return self.getTypedRuleContext(ROSMsg_Parser.Ros_messageContext,i)


        def MESSAGE_SEPARATOR(self, i:int=None):
            if i is None:
                return self.getTokens(ROSMsg_Parser.MESSAGE_SEPARATOR)
            else:
                return self.getToken(ROSMsg_Parser.MESSAGE_SEPARATOR, i)

        def EOF(self):
            return self.getToken(ROSMsg_Parser.EOF, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_ros_action_input

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRos_action_input" ):
                listener.enterRos_action_input(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRos_action_input" ):
                listener.exitRos_action_input(self)




    def ros_action_input(self):

        localctx = ROSMsg_Parser.Ros_action_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_ros_action_input)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 60
            self.ros_message()
            self.state = 61
            self.match(ROSMsg_Parser.MESSAGE_SEPARATOR)
            self.state = 62
            self.ros_message()
            self.state = 63
            self.match(ROSMsg_Parser.MESSAGE_SEPARATOR)
            self.state = 64
            self.ros_message()
            self.state = 65
            self.match(ROSMsg_Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ros_service_inputContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ros_message(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ROSMsg_Parser.Ros_messageContext)
            else:
                return self.getTypedRuleContext(ROSMsg_Parser.Ros_messageContext,i)


        def MESSAGE_SEPARATOR(self):
            return self.getToken(ROSMsg_Parser.MESSAGE_SEPARATOR, 0)

        def EOF(self):
            return self.getToken(ROSMsg_Parser.EOF, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_ros_service_input

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRos_service_input" ):
                listener.enterRos_service_input(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRos_service_input" ):
                listener.exitRos_service_input(self)




    def ros_service_input(self):

        localctx = ROSMsg_Parser.Ros_service_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_ros_service_input)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 67
            self.ros_message()
            self.state = 68
            self.match(ROSMsg_Parser.MESSAGE_SEPARATOR)
            self.state = 69
            self.ros_message()
            self.state = 70
            self.match(ROSMsg_Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rosbag_inputContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ros_message(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Ros_messageContext,0)


        def EOF(self):
            return self.getToken(ROSMsg_Parser.EOF, 0)

        def rosbag_nested_message(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ROSMsg_Parser.Rosbag_nested_messageContext)
            else:
                return self.getTypedRuleContext(ROSMsg_Parser.Rosbag_nested_messageContext,i)


        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_rosbag_input

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRosbag_input" ):
                listener.enterRosbag_input(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRosbag_input" ):
                listener.exitRosbag_input(self)




    def rosbag_input(self):

        localctx = ROSMsg_Parser.Rosbag_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_rosbag_input)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.ros_message()
            self.state = 76
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==ROSMsg_Parser.ROSBAG_MESSAGE_SEPARATOR:
                self.state = 73
                self.rosbag_nested_message()
                self.state = 78
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 79
            self.match(ROSMsg_Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rosbag_nested_messageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROSBAG_MESSAGE_SEPARATOR(self):
            return self.getToken(ROSMsg_Parser.ROSBAG_MESSAGE_SEPARATOR, 0)

        def ros_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Ros_typeContext,0)


        def ros_message(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Ros_messageContext,0)


        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_rosbag_nested_message

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRosbag_nested_message" ):
                listener.enterRosbag_nested_message(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRosbag_nested_message" ):
                listener.exitRosbag_nested_message(self)




    def rosbag_nested_message(self):

        localctx = ROSMsg_Parser.Rosbag_nested_messageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_rosbag_nested_message)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 81
            self.match(ROSMsg_Parser.ROSBAG_MESSAGE_SEPARATOR)
            self.state = 82
            self.ros_type()
            self.state = 83
            self.ros_message()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ros_messageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def field_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ROSMsg_Parser.Field_declarationContext)
            else:
                return self.getTypedRuleContext(ROSMsg_Parser.Field_declarationContext,i)


        def constant_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ROSMsg_Parser.Constant_declarationContext)
            else:
                return self.getTypedRuleContext(ROSMsg_Parser.Constant_declarationContext,i)


        def comment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ROSMsg_Parser.CommentContext)
            else:
                return self.getTypedRuleContext(ROSMsg_Parser.CommentContext,i)


        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_ros_message

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRos_message" ):
                listener.enterRos_message(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRos_message" ):
                listener.exitRos_message(self)




    def ros_message(self):

        localctx = ROSMsg_Parser.Ros_messageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_ros_message)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 90
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ROSMsg_Parser.BOOL) | (1 << ROSMsg_Parser.INT8) | (1 << ROSMsg_Parser.UINT8) | (1 << ROSMsg_Parser.BYTE) | (1 << ROSMsg_Parser.CHAR) | (1 << ROSMsg_Parser.INT16) | (1 << ROSMsg_Parser.UINT16) | (1 << ROSMsg_Parser.INT32) | (1 << ROSMsg_Parser.UINT32) | (1 << ROSMsg_Parser.INT64) | (1 << ROSMsg_Parser.UINT64) | (1 << ROSMsg_Parser.FLOAT32) | (1 << ROSMsg_Parser.FLOAT64) | (1 << ROSMsg_Parser.STRING) | (1 << ROSMsg_Parser.TIME) | (1 << ROSMsg_Parser.DURATION) | (1 << ROSMsg_Parser.HASH) | (1 << ROSMsg_Parser.IDENTIFIER) | (1 << ROSMsg_Parser.STRING_HASH))) != 0):
                self.state = 88
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
                if la_ == 1:
                    self.state = 85
                    self.field_declaration()
                    pass

                elif la_ == 2:
                    self.state = 86
                    self.constant_declaration()
                    pass

                elif la_ == 3:
                    self.state = 87
                    self.comment()
                    pass


                self.state = 92
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Field_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ROSMsg_Parser.IdentifierContext,0)


        def type_def(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Type_defContext,0)


        def array_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Array_typeContext,0)


        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_field_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterField_declaration" ):
                listener.enterField_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitField_declaration" ):
                listener.exitField_declaration(self)




    def field_declaration(self):

        localctx = ROSMsg_Parser.Field_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_field_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 95
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.state = 93
                self.type_def()
                pass

            elif la_ == 2:
                self.state = 94
                self.array_type()
                pass


            self.state = 97
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Constant_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integral_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Integral_typeContext,0)


        def identifier(self):
            return self.getTypedRuleContext(ROSMsg_Parser.IdentifierContext,0)


        def ASSIGNMENT(self):
            return self.getToken(ROSMsg_Parser.ASSIGNMENT, 0)

        def integral_value(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Integral_valueContext,0)


        def floating_point_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Floating_point_typeContext,0)


        def floating_point_value(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Floating_point_valueContext,0)


        def boolean_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Boolean_typeContext,0)


        def bool_value(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Bool_valueContext,0)


        def string_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.String_typeContext,0)


        def STRING_ASSIGNMENT(self):
            return self.getToken(ROSMsg_Parser.STRING_ASSIGNMENT, 0)

        def string_value(self):
            return self.getTypedRuleContext(ROSMsg_Parser.String_valueContext,0)


        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_constant_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant_declaration" ):
                listener.enterConstant_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant_declaration" ):
                listener.exitConstant_declaration(self)




    def constant_declaration(self):

        localctx = ROSMsg_Parser.Constant_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_constant_declaration)
        try:
            self.state = 123
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ROSMsg_Parser.INT8, ROSMsg_Parser.UINT8, ROSMsg_Parser.BYTE, ROSMsg_Parser.CHAR, ROSMsg_Parser.INT16, ROSMsg_Parser.UINT16, ROSMsg_Parser.INT32, ROSMsg_Parser.UINT32, ROSMsg_Parser.INT64, ROSMsg_Parser.UINT64]:
                self.enterOuterAlt(localctx, 1)
                self.state = 99
                self.integral_type()
                self.state = 100
                self.identifier()
                self.state = 101
                self.match(ROSMsg_Parser.ASSIGNMENT)
                self.state = 102
                self.integral_value()
                pass
            elif token in [ROSMsg_Parser.FLOAT32, ROSMsg_Parser.FLOAT64]:
                self.enterOuterAlt(localctx, 2)
                self.state = 104
                self.floating_point_type()
                self.state = 105
                self.identifier()
                self.state = 106
                self.match(ROSMsg_Parser.ASSIGNMENT)
                self.state = 109
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
                if la_ == 1:
                    self.state = 107
                    self.integral_value()
                    pass

                elif la_ == 2:
                    self.state = 108
                    self.floating_point_value()
                    pass


                pass
            elif token in [ROSMsg_Parser.BOOL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 111
                self.boolean_type()
                self.state = 112
                self.identifier()
                self.state = 113
                self.match(ROSMsg_Parser.ASSIGNMENT)
                self.state = 116
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ROSMsg_Parser.TRUE, ROSMsg_Parser.FALSE]:
                    self.state = 114
                    self.bool_value()
                    pass
                elif token in [ROSMsg_Parser.PLUS, ROSMsg_Parser.MINUS, ROSMsg_Parser.INTEGER_LITERAL]:
                    self.state = 115
                    self.integral_value()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [ROSMsg_Parser.STRING]:
                self.enterOuterAlt(localctx, 4)
                self.state = 118
                self.string_type()
                self.state = 119
                self.identifier()
                self.state = 120
                self.match(ROSMsg_Parser.STRING_ASSIGNMENT)
                self.state = 121
                self.string_value()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMENT(self):
            return self.getToken(ROSMsg_Parser.COMMENT, 0)

        def HASH(self):
            return self.getToken(ROSMsg_Parser.HASH, 0)

        def STRING_HASH(self):
            return self.getToken(ROSMsg_Parser.STRING_HASH, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_comment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComment" ):
                listener.enterComment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComment" ):
                listener.exitComment(self)




    def comment(self):

        localctx = ROSMsg_Parser.CommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_comment)
        self._la = 0 # Token type
        try:
            self.state = 128
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 125
                _la = self._input.LA(1)
                if not(_la==ROSMsg_Parser.HASH or _la==ROSMsg_Parser.STRING_HASH):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 126
                self.match(ROSMsg_Parser.COMMENT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 127
                _la = self._input.LA(1)
                if not(_la==ROSMsg_Parser.HASH or _la==ROSMsg_Parser.STRING_HASH):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ROSMsg_Parser.IDENTIFIER, 0)

        def STRING_IDENTIFIER(self):
            return self.getToken(ROSMsg_Parser.STRING_IDENTIFIER, 0)

        def INT8(self):
            return self.getToken(ROSMsg_Parser.INT8, 0)

        def UINT8(self):
            return self.getToken(ROSMsg_Parser.UINT8, 0)

        def INT16(self):
            return self.getToken(ROSMsg_Parser.INT16, 0)

        def UINT16(self):
            return self.getToken(ROSMsg_Parser.UINT16, 0)

        def INT32(self):
            return self.getToken(ROSMsg_Parser.INT32, 0)

        def UINT32(self):
            return self.getToken(ROSMsg_Parser.UINT32, 0)

        def INT64(self):
            return self.getToken(ROSMsg_Parser.INT64, 0)

        def UINT64(self):
            return self.getToken(ROSMsg_Parser.UINT64, 0)

        def BYTE(self):
            return self.getToken(ROSMsg_Parser.BYTE, 0)

        def CHAR(self):
            return self.getToken(ROSMsg_Parser.CHAR, 0)

        def FLOAT32(self):
            return self.getToken(ROSMsg_Parser.FLOAT32, 0)

        def FLOAT64(self):
            return self.getToken(ROSMsg_Parser.FLOAT64, 0)

        def TIME(self):
            return self.getToken(ROSMsg_Parser.TIME, 0)

        def DURATION(self):
            return self.getToken(ROSMsg_Parser.DURATION, 0)

        def STRING(self):
            return self.getToken(ROSMsg_Parser.STRING, 0)

        def BOOL(self):
            return self.getToken(ROSMsg_Parser.BOOL, 0)

        def TRUE(self):
            return self.getToken(ROSMsg_Parser.TRUE, 0)

        def FALSE(self):
            return self.getToken(ROSMsg_Parser.FALSE, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = ROSMsg_Parser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 130
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ROSMsg_Parser.BOOL) | (1 << ROSMsg_Parser.INT8) | (1 << ROSMsg_Parser.UINT8) | (1 << ROSMsg_Parser.BYTE) | (1 << ROSMsg_Parser.CHAR) | (1 << ROSMsg_Parser.INT16) | (1 << ROSMsg_Parser.UINT16) | (1 << ROSMsg_Parser.INT32) | (1 << ROSMsg_Parser.UINT32) | (1 << ROSMsg_Parser.INT64) | (1 << ROSMsg_Parser.UINT64) | (1 << ROSMsg_Parser.FLOAT32) | (1 << ROSMsg_Parser.FLOAT64) | (1 << ROSMsg_Parser.STRING) | (1 << ROSMsg_Parser.TIME) | (1 << ROSMsg_Parser.DURATION) | (1 << ROSMsg_Parser.TRUE) | (1 << ROSMsg_Parser.FALSE) | (1 << ROSMsg_Parser.IDENTIFIER) | (1 << ROSMsg_Parser.STRING_IDENTIFIER))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_defContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integral_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Integral_typeContext,0)


        def floating_point_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Floating_point_typeContext,0)


        def temportal_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Temportal_typeContext,0)


        def boolean_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Boolean_typeContext,0)


        def string_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.String_typeContext,0)


        def ros_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Ros_typeContext,0)


        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_type_def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_def" ):
                listener.enterType_def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_def" ):
                listener.exitType_def(self)




    def type_def(self):

        localctx = ROSMsg_Parser.Type_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_type_def)
        try:
            self.state = 138
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ROSMsg_Parser.INT8, ROSMsg_Parser.UINT8, ROSMsg_Parser.BYTE, ROSMsg_Parser.CHAR, ROSMsg_Parser.INT16, ROSMsg_Parser.UINT16, ROSMsg_Parser.INT32, ROSMsg_Parser.UINT32, ROSMsg_Parser.INT64, ROSMsg_Parser.UINT64]:
                self.enterOuterAlt(localctx, 1)
                self.state = 132
                self.integral_type()
                pass
            elif token in [ROSMsg_Parser.FLOAT32, ROSMsg_Parser.FLOAT64]:
                self.enterOuterAlt(localctx, 2)
                self.state = 133
                self.floating_point_type()
                pass
            elif token in [ROSMsg_Parser.TIME, ROSMsg_Parser.DURATION]:
                self.enterOuterAlt(localctx, 3)
                self.state = 134
                self.temportal_type()
                pass
            elif token in [ROSMsg_Parser.BOOL]:
                self.enterOuterAlt(localctx, 4)
                self.state = 135
                self.boolean_type()
                pass
            elif token in [ROSMsg_Parser.STRING]:
                self.enterOuterAlt(localctx, 5)
                self.state = 136
                self.string_type()
                pass
            elif token in [ROSMsg_Parser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 6)
                self.state = 137
                self.ros_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ros_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(ROSMsg_Parser.IDENTIFIER)
            else:
                return self.getToken(ROSMsg_Parser.IDENTIFIER, i)

        def SLASH(self):
            return self.getToken(ROSMsg_Parser.SLASH, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_ros_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRos_type" ):
                listener.enterRos_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRos_type" ):
                listener.exitRos_type(self)




    def ros_type(self):

        localctx = ROSMsg_Parser.Ros_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ros_type)
        try:
            self.state = 144
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 140
                self.match(ROSMsg_Parser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 141
                self.match(ROSMsg_Parser.IDENTIFIER)
                self.state = 142
                self.match(ROSMsg_Parser.SLASH)
                self.state = 143
                self.match(ROSMsg_Parser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Array_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_array_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Variable_array_typeContext,0)


        def fixed_array_type(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Fixed_array_typeContext,0)


        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_array_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray_type" ):
                listener.enterArray_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray_type" ):
                listener.exitArray_type(self)




    def array_type(self):

        localctx = ROSMsg_Parser.Array_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_array_type)
        try:
            self.state = 148
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 146
                self.variable_array_type()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 147
                self.fixed_array_type()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Variable_array_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_def(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Type_defContext,0)


        def OPEN_BRACKET(self):
            return self.getToken(ROSMsg_Parser.OPEN_BRACKET, 0)

        def STRING_OPEN_BRACKET(self):
            return self.getToken(ROSMsg_Parser.STRING_OPEN_BRACKET, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(ROSMsg_Parser.CLOSE_BRACKET, 0)

        def STRING_CLOSE_BRACKET(self):
            return self.getToken(ROSMsg_Parser.STRING_CLOSE_BRACKET, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_variable_array_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_array_type" ):
                listener.enterVariable_array_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_array_type" ):
                listener.exitVariable_array_type(self)




    def variable_array_type(self):

        localctx = ROSMsg_Parser.Variable_array_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_variable_array_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.type_def()
            self.state = 151
            _la = self._input.LA(1)
            if not(_la==ROSMsg_Parser.OPEN_BRACKET or _la==ROSMsg_Parser.STRING_OPEN_BRACKET):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 152
            _la = self._input.LA(1)
            if not(_la==ROSMsg_Parser.CLOSE_BRACKET or _la==ROSMsg_Parser.STRING_CLOSE_BRACKET):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fixed_array_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_def(self):
            return self.getTypedRuleContext(ROSMsg_Parser.Type_defContext,0)


        def OPEN_BRACKET(self):
            return self.getToken(ROSMsg_Parser.OPEN_BRACKET, 0)

        def INTEGER_LITERAL(self):
            return self.getToken(ROSMsg_Parser.INTEGER_LITERAL, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(ROSMsg_Parser.CLOSE_BRACKET, 0)

        def STRING_OPEN_BRACKET(self):
            return self.getToken(ROSMsg_Parser.STRING_OPEN_BRACKET, 0)

        def STRING_INTEGER_LITERAL(self):
            return self.getToken(ROSMsg_Parser.STRING_INTEGER_LITERAL, 0)

        def STRING_CLOSE_BRACKET(self):
            return self.getToken(ROSMsg_Parser.STRING_CLOSE_BRACKET, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_fixed_array_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFixed_array_type" ):
                listener.enterFixed_array_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFixed_array_type" ):
                listener.exitFixed_array_type(self)




    def fixed_array_type(self):

        localctx = ROSMsg_Parser.Fixed_array_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_fixed_array_type)
        try:
            self.state = 164
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 154
                self.type_def()
                self.state = 155
                self.match(ROSMsg_Parser.OPEN_BRACKET)
                self.state = 156
                self.match(ROSMsg_Parser.INTEGER_LITERAL)
                self.state = 157
                self.match(ROSMsg_Parser.CLOSE_BRACKET)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 159
                self.type_def()
                self.state = 160
                self.match(ROSMsg_Parser.STRING_OPEN_BRACKET)
                self.state = 161
                self.match(ROSMsg_Parser.STRING_INTEGER_LITERAL)
                self.state = 162
                self.match(ROSMsg_Parser.STRING_CLOSE_BRACKET)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Integral_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT8(self):
            return self.getToken(ROSMsg_Parser.INT8, 0)

        def UINT8(self):
            return self.getToken(ROSMsg_Parser.UINT8, 0)

        def INT16(self):
            return self.getToken(ROSMsg_Parser.INT16, 0)

        def UINT16(self):
            return self.getToken(ROSMsg_Parser.UINT16, 0)

        def INT32(self):
            return self.getToken(ROSMsg_Parser.INT32, 0)

        def UINT32(self):
            return self.getToken(ROSMsg_Parser.UINT32, 0)

        def INT64(self):
            return self.getToken(ROSMsg_Parser.INT64, 0)

        def UINT64(self):
            return self.getToken(ROSMsg_Parser.UINT64, 0)

        def BYTE(self):
            return self.getToken(ROSMsg_Parser.BYTE, 0)

        def CHAR(self):
            return self.getToken(ROSMsg_Parser.CHAR, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_integral_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegral_type" ):
                listener.enterIntegral_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegral_type" ):
                listener.exitIntegral_type(self)




    def integral_type(self):

        localctx = ROSMsg_Parser.Integral_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_integral_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ROSMsg_Parser.INT8) | (1 << ROSMsg_Parser.UINT8) | (1 << ROSMsg_Parser.BYTE) | (1 << ROSMsg_Parser.CHAR) | (1 << ROSMsg_Parser.INT16) | (1 << ROSMsg_Parser.UINT16) | (1 << ROSMsg_Parser.INT32) | (1 << ROSMsg_Parser.UINT32) | (1 << ROSMsg_Parser.INT64) | (1 << ROSMsg_Parser.UINT64))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Floating_point_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT32(self):
            return self.getToken(ROSMsg_Parser.FLOAT32, 0)

        def FLOAT64(self):
            return self.getToken(ROSMsg_Parser.FLOAT64, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_floating_point_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFloating_point_type" ):
                listener.enterFloating_point_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFloating_point_type" ):
                listener.exitFloating_point_type(self)




    def floating_point_type(self):

        localctx = ROSMsg_Parser.Floating_point_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_floating_point_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            _la = self._input.LA(1)
            if not(_la==ROSMsg_Parser.FLOAT32 or _la==ROSMsg_Parser.FLOAT64):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Temportal_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIME(self):
            return self.getToken(ROSMsg_Parser.TIME, 0)

        def DURATION(self):
            return self.getToken(ROSMsg_Parser.DURATION, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_temportal_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemportal_type" ):
                listener.enterTemportal_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemportal_type" ):
                listener.exitTemportal_type(self)




    def temportal_type(self):

        localctx = ROSMsg_Parser.Temportal_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_temportal_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            _la = self._input.LA(1)
            if not(_la==ROSMsg_Parser.TIME or _la==ROSMsg_Parser.DURATION):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class String_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(ROSMsg_Parser.STRING, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_string_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString_type" ):
                listener.enterString_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString_type" ):
                listener.exitString_type(self)




    def string_type(self):

        localctx = ROSMsg_Parser.String_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_string_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.match(ROSMsg_Parser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Boolean_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOL(self):
            return self.getToken(ROSMsg_Parser.BOOL, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_boolean_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolean_type" ):
                listener.enterBoolean_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolean_type" ):
                listener.exitBoolean_type(self)




    def boolean_type(self):

        localctx = ROSMsg_Parser.Boolean_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_boolean_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self.match(ROSMsg_Parser.BOOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(ROSMsg_Parser.PLUS, 0)

        def MINUS(self):
            return self.getToken(ROSMsg_Parser.MINUS, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_sign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSign" ):
                listener.enterSign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSign" ):
                listener.exitSign(self)




    def sign(self):

        localctx = ROSMsg_Parser.SignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_sign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 176
            _la = self._input.LA(1)
            if not(_la==ROSMsg_Parser.PLUS or _la==ROSMsg_Parser.MINUS):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Integral_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER_LITERAL(self):
            return self.getToken(ROSMsg_Parser.INTEGER_LITERAL, 0)

        def sign(self):
            return self.getTypedRuleContext(ROSMsg_Parser.SignContext,0)


        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_integral_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegral_value" ):
                listener.enterIntegral_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegral_value" ):
                listener.exitIntegral_value(self)




    def integral_value(self):

        localctx = ROSMsg_Parser.Integral_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_integral_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ROSMsg_Parser.PLUS or _la==ROSMsg_Parser.MINUS:
                self.state = 178
                self.sign()


            self.state = 181
            self.match(ROSMsg_Parser.INTEGER_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Floating_point_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REAL_LITERAL(self):
            return self.getToken(ROSMsg_Parser.REAL_LITERAL, 0)

        def sign(self):
            return self.getTypedRuleContext(ROSMsg_Parser.SignContext,0)


        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_floating_point_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFloating_point_value" ):
                listener.enterFloating_point_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFloating_point_value" ):
                listener.exitFloating_point_value(self)




    def floating_point_value(self):

        localctx = ROSMsg_Parser.Floating_point_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_floating_point_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 184
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ROSMsg_Parser.PLUS or _la==ROSMsg_Parser.MINUS:
                self.state = 183
                self.sign()


            self.state = 186
            self.match(ROSMsg_Parser.REAL_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bool_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(ROSMsg_Parser.TRUE, 0)

        def FALSE(self):
            return self.getToken(ROSMsg_Parser.FALSE, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_bool_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBool_value" ):
                listener.enterBool_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBool_value" ):
                listener.exitBool_value(self)




    def bool_value(self):

        localctx = ROSMsg_Parser.Bool_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_bool_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 188
            _la = self._input.LA(1)
            if not(_la==ROSMsg_Parser.TRUE or _la==ROSMsg_Parser.FALSE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class String_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_VALUE(self):
            return self.getToken(ROSMsg_Parser.STRING_VALUE, 0)

        def getRuleIndex(self):
            return ROSMsg_Parser.RULE_string_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString_value" ):
                listener.enterString_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString_value" ):
                listener.exitString_value(self)




    def string_value(self):

        localctx = ROSMsg_Parser.String_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_string_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self.match(ROSMsg_Parser.STRING_VALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





